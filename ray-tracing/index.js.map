{"version":3,"sources":["webpack:///webpack/bootstrap a87213bc2377609f8d2b","webpack:///./src/ray-tracing/vector.js","webpack:///./src/ray-tracing/index.js","webpack:///./src/ray-tracing/raytracer.js","webpack:///./src/ray-tracing/surfaces.js","webpack:///./src/ray-tracing/scene.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACrFA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;AClDA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,YAAY;AAC/B;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAA+D,wDAAwD;AACvH;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;AC/QA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,E","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a87213bc2377609f8d2b","function add(a, b) {\r\n    return [\r\n        a[0] + b[0],\r\n        a[1] + b[1],\r\n        a[2] + b[2],\r\n    ];\r\n}\r\n\r\nfunction subtract(a, b) {\r\n    return [\r\n        a[0] - b[0],\r\n        a[1] - b[1],\r\n        a[2] - b[2],\r\n    ];\r\n}\r\n\r\nfunction multiply(a, b) {\r\n    return [\r\n        a[0] * b[0],\r\n        a[1] * b[1],\r\n        a[2] * b[2],\r\n    ]\r\n}\r\n\r\nfunction dotProduct(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r\n}\r\n\r\nfunction crossProduct(a, b) {\r\n    return [\r\n        a[1] * b[2] - a[2] * b[1],\r\n        a[2] * b[0] - a[0] * b[2],\r\n        a[0] * b[1] - a[1] * b[0],\r\n    ];\r\n}\r\n\r\nfunction magnitude(a) {\r\n    var x = a[0], y = a[1], z = a[2]\r\n    return Math.sqrt(x * x + y * y + z * z);\r\n}\r\n\r\nfunction scale(a, s) {\r\n    return [\r\n        a[0] * s,\r\n        a[1] * s,\r\n        a[2] * s\r\n    ];\r\n}\r\n\r\nfunction normalize(a) {\r\n    var s = 1 / magnitude(a);\r\n    return [\r\n        a[0] * s,\r\n        a[1] * s,\r\n        a[2] * s,\r\n    ];\r\n}\r\n\r\nfunction clamp(a, range) {\r\n    var low = range[0], high = range[1];\r\n    return [\r\n        Math.max(low, Math.min(high, a[0])),\r\n        Math.max(low, Math.min(high, a[1])),\r\n        Math.max(low, Math.min(high, a[2]))\r\n    ];\r\n}\r\n\r\nfunction reflect(a, b) {\r\n    return subtract(a, scale(b, 2 * dotProduct(a, b)));\r\n}\r\n\r\nvar up = [0, 1, 0];\r\n\r\nmodule.exports = {\r\n    add,\r\n    subtract,\r\n    multiply,\r\n    dotProduct,\r\n    crossProduct,\r\n    magnitude,\r\n    scale,\r\n    normalize,\r\n    clamp,\r\n    reflect,\r\n    up\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ray-tracing/vector.js\n// module id = 0\n// module chunks = 0","var raytracer = require('./raytracer');\r\nvar scene = require('./scene');\r\n\r\nrender(scene, 'c');\r\n\r\nvar textarea = document.getElementById('json');\r\ntextarea.value = JSON.stringify(scene, null, 3);\r\n\r\nvar renderButton = document.getElementById('render');\r\nrenderButton.onclick = function () {\r\n    var scene = JSON.parse(textarea.value);\r\n    render(scene);\r\n};\r\n\r\nfunction render(scene) {\r\n    var visual = document.getElementById('visual');\r\n    \r\n    if (scene.settings.stereoscopic.enabled) {\r\n        visual.style.width = '100vw';\r\n        visual.style.height = '100vh';\r\n    } else {\r\n        visual.style = '';\r\n    }\r\n\r\n    var canvas = document.getElementById('c');\r\n    var width = canvas.clientWidth;\r\n    var height = canvas.clientHeight;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    var ctx = canvas.getContext('2d');\r\n    ctx.webkitImageSmoothingEnabled = false;\r\n    ctx.mozImageSmoothingEnabled = false;\r\n    ctx.imageSmoothingEnabled = false;\r\n\r\n    var img = raytracer.renderScene(scene, width, height);\r\n    for (var y = 0; y < height; y++) {\r\n        setTimeout(function (y) {\r\n            var imageData = ctx.createImageData(width, 1);\r\n            for (var x = 0; x < width; x++) {\r\n                var color = img.next().value;\r\n                i = x * 4;\r\n                imageData.data[i + 0] = color[0];\r\n                imageData.data[i + 1] = color[1];\r\n                imageData.data[i + 2] = color[2];\r\n                imageData.data[i + 3] = 255;\r\n            }\r\n            ctx.putImageData(imageData, 0, y);\r\n        }.bind(null, y), 1);\r\n    }\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ray-tracing/index.js\n// module id = 1\n// module chunks = 0","var vec = require('./vector');\r\nvar surfaces = require('./surfaces');\r\n\r\nvar atInfinity = { t: Infinity };\r\n\r\nvar intersectFunctions = {\r\n    sphere: intersectSphere,\r\n    plane: intersectPlane,\r\n    polygon: intersectPolygon\r\n};\r\n\r\nfunction* renderScene(scene, width, height) {\r\n    prepareScene(scene);\r\n\r\n    var fovRadians = (scene.camera.fov / 2) * Math.PI / 180;\r\n    var aspectRatio = height / width;\r\n    var halfWidth = Math.tan(fovRadians);\r\n    var halfHeight = aspectRatio * halfWidth;\r\n    var camerawidth = halfWidth * 2;\r\n    var cameraheight = halfHeight * 2;\r\n    var pixelWidth = camerawidth / (width - 1);\r\n    var pixelHeight = cameraheight / (height - 1);\r\n\r\n    var traceFrom2d = function (position, lookAt, x, y) {\r\n        var eyeVector = vec.normalize(vec.subtract(lookAt, position));\r\n        var vRight = vec.normalize(vec.crossProduct(vec.up, eyeVector));\r\n        var vUp = vec.normalize(vec.crossProduct(eyeVector, vRight));\r\n\r\n        var xComponent = vec.scale(vRight, (x * pixelWidth) - halfWidth);\r\n        var yComponent = vec.scale(vUp, halfHeight - (y * pixelHeight));\r\n\r\n        var ray = {\r\n            point: position,\r\n            vector: vec.normalize(vec.add(eyeVector, vec.add(xComponent, yComponent)))\r\n        };\r\n\r\n        var color = traceRay(scene, ray, 0);\r\n        var scaledColor = vec.scale(vec.clamp(color, [0, 1]), 255);\r\n        return scaledColor;\r\n    };\r\n\r\n    function antiAlias(f) {\r\n        return function (position, lookAt, x, y) {\r\n            var c1 = f(position, lookAt, x + .25, y + .25);\r\n            var c2 = f(position, lookAt, x + .75, y + .25);\r\n            var c3 = f(position, lookAt, x + .25, y + .75);\r\n            var c4 = f(position, lookAt, x + .75, y + .75);\r\n\r\n            return vec.scale(vec.add(vec.add(c1, c2), vec.add(c3, c4)), .25);\r\n        };\r\n    }\r\n\r\n    function drunkMode(f, r, samples) {\r\n        return function (position, lookAt, x, y) {\r\n            color = [0, 0, 0];\r\n            for (var t = 0; t <= 2 * Math.PI; t += Math.PI / samples) {\r\n                var contribution = f(position, lookAt, x + r * Math.cos(t), y + r * Math.sin(t));\r\n                color = vec.add(color, contribution);\r\n            }\r\n\r\n            return vec.scale(color, 1 / samples);\r\n        };\r\n    }\r\n\r\n    function depthOfField(f, r, samples) {\r\n        return function(position, lookAt, x, y) {\r\n            var color = [0, 0, 0];\r\n\r\n            var eyeVector = vec.normalize(vec.subtract(lookAt, position));\r\n            var vRight = vec.normalize(vec.crossProduct(vec.up, eyeVector));\r\n            var vUp = vec.normalize(vec.crossProduct(eyeVector, vRight));\r\n\r\n            for(var t = 0; t < 2 * Math.PI; t += 2 * Math.PI / samples) {\r\n                var leftRight = vec.scale(vRight, r * Math.cos(t));\r\n                var upDown = vec.scale(vUp, r * Math.sin(t));\r\n                var newPosition = vec.add(position, vec.add(leftRight, upDown));\r\n                var contribution = f(newPosition, lookAt, x, y);\r\n                color = vec.add(color, contribution);\r\n            }\r\n\r\n            return vec.scale(color, 1 / samples);\r\n        };\r\n    }\r\n\r\n    function stereoscopic(f, r) {\r\n        return function(position, lookAt, x, y) {\r\n            var eyeVector = vec.normalize(vec.subtract(lookAt, position));\r\n            var vRight = vec.normalize(vec.crossProduct(vec.up, eyeVector));\r\n            var vUp = vec.normalize(vec.crossProduct(eyeVector, vRight));\r\n\r\n            var dir = scene.settings.stereoscopic.vrHeadset ? -1 : 1;\r\n\r\n            if (x < width / 2) {\r\n                var leftRight = vec.scale(vRight, r * dir);\r\n                var newPosition = vec.add(position, leftRight);\r\n                return f(newPosition, lookAt, x * 2, y * 2 - height / 2);\r\n            } else {\r\n                var leftRight = vec.scale(vRight, -r * dir);\r\n                var newPosition = vec.add(position, leftRight);\r\n                return f(newPosition, lookAt, x * 2 % width, y * 2 - height / 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    var trace = traceFrom2d;\r\n\r\n    if (scene.settings.stereoscopic.enabled) {\r\n        trace = stereoscopic(trace, scene.settings.stereoscopic.radius);\r\n    }\r\n\r\n    if (scene.settings.depthOfField.enabled) {\r\n        trace = depthOfField(trace, scene.settings.depthOfField.radius, scene.settings.depthOfField.samples);\r\n    }\r\n\r\n    if (scene.settings.antiAlias) {\r\n        trace = antiAlias(trace);\r\n    }\r\n\r\n    var result = [];\r\n    for (var y = 0; y < height; y++) {\r\n        result[y] = [];\r\n        for (var x = 0; x < width; x++) {\r\n            yield trace(scene.camera.position, scene.camera.lookAt, x, y);\r\n        }\r\n    }\r\n}\r\n\r\nfunction prepareScene(scene) {\r\n    for (var shape of scene.shapes) {\r\n        if (shape.type === 'polygon') {\r\n            shape.edges = [];\r\n            for (var i = 0; i < shape.vertices.length; i++) {\r\n                shape.edges.push(vec.subtract(shape.vertices[(i + 1) % shape.vertices.length], shape.vertices[i]));\r\n            }\r\n            shape.point = shape.vertices[0];\r\n            shape.normal = vec.normalize(vec.crossProduct(shape.edges[0], shape.edges[1]));\r\n        }\r\n    }\r\n}\r\n\r\nfunction traceRay(scene, ray, depth, excludedShape) {\r\n    if (depth > scene.settings.reflectionDepth)\r\n        return scene.ambient;\r\n\r\n    var intersection = intersectAllShapes(scene, ray, excludedShape);\r\n\r\n    if (!Number.isFinite(intersection.t)) return scene.ambient;\r\n\r\n    var lighting = colorAtIntersection(scene, intersection, ray);\r\n\r\n    var reflectedRay = {\r\n        point: intersection.pointAtTime,\r\n        vector: vec.reflect(ray.vector, intersection.normal)\r\n    };\r\n\r\n    var reflection = traceRay(scene, reflectedRay, ++depth, intersection.shape);\r\n\r\n    return vec.add(lighting, vec.multiply(intersection.shape.specular, reflection));\r\n}\r\n\r\nfunction intersectAllShapes(scene, ray, excludedShape) {\r\n    var intersection = atInfinity;\r\n    for (var shape of scene.shapes) {\r\n        if (shape === excludedShape) continue;\r\n        var newIntersection = intersectFunctions[shape.type](ray, shape);\r\n        if (newIntersection.t > 0 && newIntersection.t < intersection.t)\r\n            intersection = newIntersection;\r\n    }\r\n    return intersection;\r\n}\r\n\r\nfunction intersectPlane(ray, shape) {\r\n    var rayToPlane = vec.subtract(shape.point, ray.point);\r\n    var dot = vec.dotProduct(ray.vector, shape.normal);\r\n    var t = vec.dotProduct(rayToPlane, shape.normal) / dot;\r\n    if (t < 0) return atInfinity;\r\n\r\n    var pointAtTime = vec.add(ray.point, vec.scale(ray.vector, t));\r\n    var normal = (dot > 0) ? vec.scale(shape.normal, -1) : shape.normal;\r\n    normal = surfaces[shape.surface](normal, pointAtTime);\r\n\r\n    return { shape, t, normal, pointAtTime };\r\n}\r\n\r\nfunction intersectPolygon(ray, shape) {\r\n    var intersection = intersectPlane(ray, shape);\r\n    if (!Number.isFinite(intersection.t)) return atInfinity;\r\n\r\n    for (var i = 0; i < shape.vertices.length; i++) {\r\n        var c0 = vec.subtract(intersection.pointAtTime, shape.vertices[i]);\r\n        if (vec.dotProduct(shape.normal, vec.crossProduct(shape.edges[i], c0)) < 0) return atInfinity;\r\n    }\r\n\r\n    return intersection;\r\n}\r\n\r\nfunction intersectSphere(ray, shape) {\r\n    var L = vec.subtract(ray.point, shape.center);\r\n    var a = vec.dotProduct(ray.vector, ray.vector);\r\n    var b = 2 * vec.dotProduct(ray.vector, L);\r\n    var c = vec.dotProduct(L, L) - shape.radius * shape.radius;\r\n\r\n    var t = solveQuadratic(a, b, c);\r\n    if (!Number.isFinite(t))\r\n        return atInfinity;\r\n\r\n    var pointAtTime = vec.add(ray.point, vec.scale(ray.vector, t));\r\n\r\n    var normal = vec.normalize(vec.subtract(pointAtTime, shape.center));\r\n    normal = surfaces[shape.surface](normal, pointAtTime);\r\n\r\n    return { shape, t, pointAtTime, normal };\r\n}\r\n\r\nfunction colorAtIntersection(scene, intersection, ray) {\r\n    var shape = intersection.shape;\r\n    var normal = intersection.normal;\r\n\r\n    // ambient\r\n    var color = vec.multiply(scene.ambient, shape.ambient);\r\n\r\n    for (var light of scene.lights) {\r\n        var pointToLight = vec.subtract(light.position, intersection.pointAtTime);\r\n\r\n        // shadows\r\n        if (scene.settings.shadows) {\r\n            var length = vec.magnitude(pointToLight);\r\n            pointToLight = vec.normalize(pointToLight);\r\n\r\n            var lightIntersection = intersectAllShapes(scene, { point: intersection.pointAtTime, vector: pointToLight }, intersection.shape);\r\n            if (lightIntersection.t < length) continue;\r\n        } else {\r\n            pointToLight = vec.normalize(pointToLight);\r\n        }\r\n\r\n        // diffuse\r\n        var cos = Math.max(0, vec.dotProduct(normal, pointToLight));\r\n        var diffuse = vec.scale(vec.multiply(light.intensity, shape.diffuse), cos);\r\n        color = vec.add(color, diffuse);\r\n\r\n        // specular\r\n        if (cos > 0) {\r\n            var pointToCamera = vec.scale(ray.vector, -1);\r\n            var reflection = vec.normalize(vec.add(pointToLight, pointToCamera));\r\n            var reflectionCos = Math.max(0, vec.dotProduct(normal, reflection));\r\n            var specular = vec.scale(vec.multiply(light.intensity, shape.specular), Math.pow(reflectionCos, shape.exponent));\r\n            color = vec.add(color, specular);\r\n        }\r\n    }\r\n\r\n    return color;\r\n}\r\n\r\nfunction solveQuadratic(a, b, c) {\r\n    var discr = b * b - 4 * a * c;\r\n    if (discr > 0) {\r\n        var q = (b > 0)\r\n            ? -0.5 * (b + Math.sqrt(discr))\r\n            : -0.5 * (b - Math.sqrt(discr))\r\n        var x0 = q / a;\r\n        var x1 = c / q;\r\n        return Math.min(x0, x1);\r\n    } else if (discr === 0) {\r\n        return -0.5 * b / a;\r\n    } else {\r\n        return NaN;\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    renderScene\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ray-tracing/raytracer.js\n// module id = 2\n// module chunks = 0","var vec = require('./vector');\r\n\r\nfunction slightlyRough(normal, point) {\r\n    return vec.normalize([\r\n        normal[0] + (Math.random() - .5) * .05,\r\n        normal[1] + (Math.random() - .5) * .05,\r\n        normal[2] + (Math.random() - .5) * .05,\r\n    ]);\r\n}\r\n\r\nfunction veryRough(normal, point) {\r\n    return vec.normalize([\r\n        normal[0] + (Math.random() - .5) * .2,\r\n        normal[1] + (Math.random() - .5) * .2,\r\n        normal[2] + (Math.random() - .5) * .2,\r\n    ]);\r\n}\r\n\r\nfunction smooth(normal, point) {\r\n    return normal;\r\n}\r\n\r\nmodule.exports = {\r\n    slightlyRough,\r\n    veryRough,\r\n    smooth\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ray-tracing/surfaces.js\n// module id = 3\n// module chunks = 0","module.exports = {\r\n    settings: {\r\n        reflectionDepth: 3,\r\n        antiAlias: true,\r\n        shadows: true,\r\n        depthOfField: {\r\n            enabled: false,\r\n            radius: .15,\r\n            samples: 4\r\n        },\r\n        stereoscopic: {\r\n            enabled: false,\r\n            radius: .2,\r\n            vrHeadset: true\r\n        },\r\n    },\r\n    camera: {\r\n        position: [-0.5, 1.5, 0],\r\n        lookAt: [1, .5, 3],\r\n        fov: 90,\r\n    },\r\n    shapes: [\r\n        // top\r\n        {\r\n            type: 'polygon',\r\n            vertices: [\r\n                [.5, 1, 2],\r\n                [.5, 1, 1],\r\n                [1.5, 1, 1],\r\n                [1.5, 1, 2],\r\n            ],\r\n            // brass\r\n            ambient: [.33, .22, .03],\r\n            diffuse: [.78, .57, .11],\r\n            specular: [.99, .94, .81],\r\n            exponent: 27.8,\r\n            surface: 'slightlyRough'\r\n        },\r\n        // bottom\r\n        {\r\n            type: 'polygon',\r\n            vertices: [\r\n                [.5, 0, 1],\r\n                [.5, 0, 2],\r\n                [1.5, 0, 2],\r\n                [1.5, 0, 1],\r\n            ],\r\n            // brass\r\n            ambient: [.33, .22, .03],\r\n            diffuse: [.78, .57, .11],\r\n            specular: [.99, .94, .81],\r\n            exponent: 27.8,\r\n            surface: 'slightlyRough'\r\n        },\r\n        // left\r\n        {\r\n            type: 'polygon',\r\n            vertices: [\r\n                [.5, 1, 2],\r\n                [.5, 0, 2],\r\n                [.5, 0, 1],\r\n                [.5, 1, 1]\r\n            ],\r\n            // brass\r\n            ambient: [.33, .22, .03],\r\n            diffuse: [.78, .57, .11],\r\n            specular: [.99, .94, .81],\r\n            exponent: 27.8,\r\n            surface: 'slightlyRough'\r\n        },\r\n        // right\r\n        {\r\n            type: 'polygon',\r\n            vertices: [\r\n                [1.5, 1, 2],\r\n                [1.5, 0, 2],\r\n                [1.5, 0, 1],\r\n                [1.5, 1, 1]\r\n            ],\r\n            // brass\r\n            ambient: [.33, .22, .03],\r\n            diffuse: [.78, .57, .11],\r\n            specular: [.99, .94, .81],\r\n            exponent: 27.8,\r\n            surface: 'slightlyRough'\r\n        },\r\n        // front\r\n        {\r\n            type: 'polygon',\r\n            vertices: [\r\n                [.5, 1, 1],\r\n                [.5, 0, 1],\r\n                [1.5, 0, 1],\r\n                [1.5, 1, 1]\r\n            ],\r\n            // brass\r\n            ambient: [.33, .22, .03],\r\n            diffuse: [.78, .57, .11],\r\n            specular: [.99, .94, .81],\r\n            exponent: 27.8,\r\n            surface: 'slightlyRough'\r\n        },\r\n        // back\r\n        {\r\n            type: 'polygon',\r\n            vertices: [\r\n                [.5, 1, 2],\r\n                [.5, 0, 2],\r\n                [1.5, 0, 2],\r\n                [1.5, 1, 2]\r\n            ],\r\n            // brass\r\n            ambient: [.33, .22, .03],\r\n            diffuse: [.78, .57, .11],\r\n            specular: [.99, .94, .81],\r\n            exponent: 27.8,\r\n            surface: 'slightlyRough'\r\n        },\r\n\r\n        {\r\n            type: 'plane',\r\n            point: [0, -1.5, 10],\r\n            normal: [0, 1, 0],\r\n            // black plastic\r\n            ambient: [.0, .0, .0],\r\n            diffuse: [.01, .01, .01],\r\n            specular: [.5, .5, .5],\r\n            exponent: 32,\r\n            surface: 'slightlyRough'\r\n        },\r\n        {\r\n            type: 'sphere',\r\n            center: [-1, 0, 4],\r\n            radius: 1.5,\r\n            // gold\r\n            ambient: [.25, .20, .07],\r\n            diffuse: [.75, .61, .23],\r\n            specular: [.62, .55, .63],\r\n            exponent: 27.8,\r\n            surface: 'smooth'\r\n        },\r\n        {\r\n            type: 'sphere',\r\n            center: [1, .5, 3],\r\n            radius: .5,\r\n            // copper\r\n            ambient: [.19, .07, .02],\r\n            diffuse: [.7, .27, .08],\r\n            specular: [.25, .13, .08],\r\n            exponent: 12.8,\r\n            surface: 'veryRough'\r\n        },\r\n        // {\r\n        //     type: 'sphere',\r\n        //     center: [.5, -.35, 1.5],\r\n        //     radius: .5,\r\n        //     // silver\r\n        //     ambient: [.19, .19, .19],\r\n        //     diffuse: [.51, .51, .51],\r\n        //     specular: [.51, .51, .51],\r\n        //     exponent: 51.2,\r\n        //     surface: 'slightlyRough'\r\n        // }\r\n    ],\r\n    lights: [\r\n        {\r\n            position: [-5, 10, 0],\r\n            intensity: [1, 1, 1]\r\n        },\r\n        {\r\n            position: [8, -1.25, 4],\r\n            intensity: [0, 0, .7]\r\n        },\r\n        {\r\n            position: [-2, -1.25, 2],\r\n            intensity: [.25, 0, 0]\r\n        },\r\n    ],\r\n    ambient: [.1, .1, .5]\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ray-tracing/scene.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}